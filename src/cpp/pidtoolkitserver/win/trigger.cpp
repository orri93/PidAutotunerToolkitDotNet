#include <win/trigger.h>

namespace gos {
namespace pid {
namespace toolkit {
namespace service {
namespace windows {

namespace trigger {

namespace check {
bool supported() {
	// osVersionInfoToCompare contains the OS version requirements to compare
	OSVERSIONINFOEX osVersionInfoToCompare = { sizeof(osVersionInfoToCompare) };
	osVersionInfoToCompare.dwMajorVersion = 6;
	osVersionInfoToCompare.dwMinorVersion = 1;		// Windows 7
	osVersionInfoToCompare.wServicePackMajor = 0;
	osVersionInfoToCompare.wServicePackMinor = 0;

	// Initialize the condition mask with ULONGLONG VER_SET_CONDITION(
// ULONGLONG dwlConditionMask, DWORD dwTypeBitMask, BYTE dwConditionMask)
	ULONGLONG comparisonInfo = 0;
	BYTE conditionMask = VER_GREATER_EQUAL;
	VER_SET_CONDITION(comparisonInfo, VER_MAJORVERSION, conditionMask);
	VER_SET_CONDITION(comparisonInfo, VER_MINORVERSION, conditionMask);
	VER_SET_CONDITION(comparisonInfo, VER_SERVICEPACKMAJOR, conditionMask);
	VER_SET_CONDITION(comparisonInfo, VER_SERVICEPACKMINOR, conditionMask);

	// Compares a set of operating system version requirements to the 
  // corresponding values for the currently running version of the system.
	return VerifyVersionInfo(&osVersionInfoToCompare, VER_MAJORVERSION |
		VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
		comparisonInfo);
}
}

namespace information {
bool get(SC_HANDLE hService, LPBOOL lpfIsTriggerStart) {
	// Get the service trigger info size of the current service
	DWORD cbBytesNeeded = 0;
	QueryServiceConfig2(hService, SERVICE_CONFIG_TRIGGER_INFO, NULL, 0, &cbBytesNeeded);
	if (ERROR_INSUFFICIENT_BUFFER != GetLastError()) {
		return FALSE;
	}

	// Allocate memory for the service trigger info struct
	PBYTE lpBuffer = (PBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbBytesNeeded);
	if (lpBuffer == NULL) {
		return FALSE;
	}

	// Retrieve the service trigger info
	DWORD dwErr = ERROR_SUCCESS;
	if (QueryServiceConfig2(hService, SERVICE_CONFIG_TRIGGER_INFO, lpBuffer, cbBytesNeeded, &cbBytesNeeded)) {
		PSERVICE_TRIGGER_INFO psti = (PSERVICE_TRIGGER_INFO)lpBuffer;

		*lpfIsTriggerStart = (psti->cTriggers > 0);

		// You can retrieve more trigger information of the service
		/*for (int i = 0; i < pTriggerInfo->cTriggers; i++)
		{
			// You can access each SERVICE_TRIGGER struct through
			// pTriggerInfo->pTriggers[i];
		}*/
	} else {
		dwErr = GetLastError();
	}

	// Free the memory of the service trigger info struct
	HeapFree(GetProcessHeap(), 0, lpBuffer);

	if (dwErr == ERROR_SUCCESS) {
		return true;
	} else {
		SetLastError(dwErr);
		return false;
	}
}
}

bool set(SC_HANDLE hService) {
	// Hardware ID generated by the USB storage port driver
	wchar_t szDeviceData[] = L"USBSTOR\\GenDisk";

	// Allocate and set the SERVICE_TRIGGER_SPECIFIC_DATA_ITEM structure
	SERVICE_TRIGGER_SPECIFIC_DATA_ITEM deviceData = { 0 };
	deviceData.dwDataType = SERVICE_TRIGGER_DATA_TYPE_STRING;
	deviceData.cbData = sizeof(szDeviceData);
	deviceData.pData = (PBYTE)szDeviceData;

	// Allocate and set the SERVICE_TRIGGER structure
	SERVICE_TRIGGER serviceTrigger = { 0 };
	serviceTrigger.dwTriggerType = SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL;
	serviceTrigger.dwAction = SERVICE_TRIGGER_ACTION_SERVICE_START;
	serviceTrigger.pTriggerSubtype = const_cast<GUID*>(&GUID_DEVINTERFACE_DISK);
	serviceTrigger.cDataItems = 1;
	serviceTrigger.pDataItems = &deviceData;

	// Allocate and set the SERVICE_TRIGGER_INFO structure
	SERVICE_TRIGGER_INFO serviceTriggerInfo = { 0 };
	serviceTriggerInfo.cTriggers = 1;
	serviceTriggerInfo.pTriggers = &serviceTrigger;

	// Call ChangeServiceConfig2 with the SERVICE_CONFIG_TRIGGER_INFO level 
	// and pass to it the address of the SERVICE_TRIGGER_INFO structure
	return ChangeServiceConfig2(hService, SERVICE_CONFIG_TRIGGER_INFO, &serviceTriggerInfo);
}

}

}
}
}
}
}
